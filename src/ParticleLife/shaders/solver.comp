#version 430

#pragma optimize(on)

layout(local_size_x = {LocalSizeX}) in;

struct ShaderConfig {
    int particleCount;
    float dt;
    float sigma2;
    float clampVel;
    float clampAcc;
    float width;
    float height;
    float maxDist;
    int speciesCount;
};

struct Particle
{
   vec2 position;
   vec2 velocity;
   int species;
   int _pad;   // padding to 24 bytes
};

// input buffer - only configuration
layout(std430, binding = 0) buffer ConfigBuffer {
    ShaderConfig config;
};

layout(std430, binding = 1) readonly buffer InputBuffer
{
    Particle inParticles[];
};

layout(std430, binding = 2) writeonly buffer OutputBuffer
{
    Particle outParticles[];
};

layout(std430, binding = 3) writeonly buffer VertexBuffer
{
    Particle displayParticles[];
};


const float M_PI        = 3.14159265358979323846;
const float CONSTANT_G  = 0.1;

void torus_pos(inout vec2 pos)
{
    if (pos.x > config.width)
        pos.x -= config.width;
    else if (pos.x < 0)
        pos.x += config.width;

    if (pos.y > config.height)
        pos.y -= config.height;
    else if (pos.y < 0)
        pos.y += config.height;
}

void torus_dist(inout vec2 dist)
{
    if (dist.x > config.width / 2)
        dist.x = abs(dist.x - config.width);

    if (dist.y > config.height / 2)
        dist.y = abs(dist.y - config.height);
}


void update_one(uint idx)
{
    vec2 pos = inParticles[idx].position;
    vec2 vel = inParticles[idx].velocity;

    for(uint otherIdx = 0; otherIdx < config.particleCount; otherIdx++)
        if (idx != otherIdx)
        {
             Particle other = inParticles[otherIdx];
             vec2 simpleDist = vec2(abs(pos.x - other.position.x), abs(pos.y - other.position.y));
             torus_dist(simpleDist);
        }

    // integrate position
    pos += vel * config.dt;
    torus_pos(pos);

    outParticles[idx].position = pos;
    outParticles[idx].velocity = vel;
}

void duplicate(Particle particle, uint nr, uint idx, vec2 traslation)
{
    displayParticles[idx + nr * config.particleCount] = particle;
    displayParticles[idx + nr * config.particleCount].position += traslation;
}

void main()
{
    uint idx = gl_GlobalInvocationID.x;

    if (idx >=0 && idx < config.particleCount) 
    {
        update_one(idx);
        Particle particle = outParticles[idx];

        displayParticles[idx] = particle;
        duplicate(particle, 1, idx, vec2(config.width, 0));
        duplicate(particle, 2, idx, vec2(-config.width, 0));
        duplicate(particle, 3, idx, vec2(0, config.height));
        duplicate(particle, 4, idx, vec2(0, -config.height));
        duplicate(particle, 5, idx, vec2(-config.width, -config.height));
        duplicate(particle, 6, idx, vec2(config.width, -config.height));
        duplicate(particle, 7, idx, vec2(-config.width, config.height));
        duplicate(particle, 8, idx, vec2(config.width, config.height));
    }
}