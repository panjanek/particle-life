#version 430

#pragma optimize(on)

layout(local_size_x = {LocalSizeX}) in;

struct ShaderConfig {
    int particleCount;
    float dt;
    float sigma2;
    float clampVel;
    float clampAcc;
    float width;
    float height;
    float maxDist;
    int speciesCount;
};

struct Particle
{
   vec2 position;
   vec2 velocity;
   int species;
   int _pad;   // padding to 24 bytes
};

layout(std140, binding = 0) buffer ConfigBuffer {
    ShaderConfig config;
};

layout(std430, binding = 1) readonly buffer InputBuffer
{
    Particle inParticles[];
};

layout(std430, binding = 2) writeonly buffer OutputBuffer
{
    Particle outParticles[];
};

layout(std430, binding = 3) writeonly buffer VertexBuffer
{
    Particle displayParticles[];
};

layout(std140, binding = 4) buffer ForceBuffer {
    vec4 forces;
};



const uint  MAX_SPECIES_COUNT = 10;
const uint  KEYPOINTS_COUNT   = 6;

void torus_pos(inout vec2 pos)
{
    if (pos.x > config.width)
        pos.x -= config.width;
    else if (pos.x < 0)
        pos.x += config.width;

    if (pos.y > config.height)
        pos.y -= config.height;
    else if (pos.y < 0)
        pos.y += config.height;
}

void torus_dist(inout vec2 d)
{
    if (abs(d.x) > config.width / 2)
        d.x -= config.width*sign(d.x);

    if (abs(d.y) > config.height / 2)
        d.y -= config.height*sign(d.y);
}

float evaluateForce(const vec2 keypoints[KEYPOINTS_COUNT], float dist)
{
    // Clamp distance to valid range
    dist = clamp(dist, keypoints[0].x, keypoints[5].x);

    // Find the segment [i, i+1] that contains dist
    for (int i = 0; i < KEYPOINTS_COUNT-1; ++i)
    {
        float x0 = keypoints[i].x;
        float x1 = keypoints[i + 1].x;

        if (dist <= x1)
        {
            float t = (dist - x0) / (x1 - x0);
            return mix(keypoints[i].y, keypoints[i + 1].y, t);
        }
    }

    // Safety fallback (should never happen)
    return 0.0;
}


void update_one(uint idx)
{
    vec2 pos = inParticles[idx].position;
    vec2 vel = inParticles[idx].velocity;
    int spec = inParticles[idx].species;

   const vec2 force1[6] = vec2[6](
        vec2(0, -5),
        vec2(10, 0),
        vec2(20, 5),
        vec2(40, 0),
        vec2(50, 0),
        vec2(60, 0)
    );

    const vec2 force2[6] = vec2[6](
        vec2(0, -5),
        vec2(10, 0),
        vec2(20, -5),
        vec2(40, 0),
        vec2(50, 0),
        vec2(60, 0)
    );

    vec2 acc = vec2(0.0);
    for(uint otherIdx = 0; otherIdx < config.particleCount; otherIdx++)
        if (idx != otherIdx)
        {
             Particle other = inParticles[otherIdx];
             vec2 d = other.position - pos;
             torus_dist(d);
             if (abs(d.x) <= config.maxDist && abs(d.y) <= config.maxDist)
             {

                 float r2 = dot(d, d);
                 float r = sqrt(r2);

                 float f = evaluateForce(force1, r);

                 //if (spec != other.species && spec!=0)
                 //    f = evaluateForce(force2, r);

                 acc += f*d/r;
             }

        }


    vel += acc * config.dt;
    vel *= (1.0 - 0.5 * config.dt);
    pos += vel * config.dt;
    torus_pos(pos);

    outParticles[idx].position = pos;
    outParticles[idx].velocity = vel;
}

void duplicate(Particle particle, uint nr, uint idx, vec2 traslation)
{
    displayParticles[idx + nr * config.particleCount] = particle;
    displayParticles[idx + nr * config.particleCount].position += traslation;
}

void main()
{
    uint idx = gl_GlobalInvocationID.x;

    if (idx >=0 && idx < config.particleCount) 
    {
        update_one(idx);
        Particle particle = outParticles[idx];

        displayParticles[idx] = particle;
        duplicate(particle, 1, idx, vec2(config.width, 0));
        duplicate(particle, 2, idx, vec2(-config.width, 0));
        duplicate(particle, 3, idx, vec2(0, config.height));
        duplicate(particle, 4, idx, vec2(0, -config.height));
        duplicate(particle, 5, idx, vec2(-config.width, -config.height));
        duplicate(particle, 6, idx, vec2(config.width, -config.height));
        duplicate(particle, 7, idx, vec2(-config.width, config.height));
        duplicate(particle, 8, idx, vec2(config.width, config.height));
    }
}